\chapter{Implementation Details\label{chap:implementation_details}}

\section{Background on Android Application Development}

\subsection{The Android OS}

The Android OS was initiated as an open source project by Google  
to make application development easier for mobile devices. In order to 
do so, Google engineers created a customized Java Virtual Machine 
(called Dalvik VM) with resource saving features 
to make running Java applications on embedded devices feasible.
A large section of the Java Standard Library was then bolted onto the 
JVM by leveraging the open source Apache Harmony project.\todo{cite both} 
The typical structure of an Android Application built on the Android OS 
is shown in Figure \ref{fig:Android_OS_Structure}.

\begin{figure}
\centering
\begin{picture}(300,300)
%\graphpaper(0,0)(300,300)
\put(0,0){\framebox(300,30){Device Hardware}}
\put(0,50){\framebox(300,30){Android OS}}
\put(0,100){\framebox(80,30){Android App}}\put(110,100){\framebox(80,30){Android App}}\put(220,100){\framebox(80,30){Android App}}
\put(40,100){\vector(0,-1){20}}\put(150,100){\vector(0,-1){20}}\put(260,100){\vector(0,-1){20}}
\end{picture}
\caption{Typical Structure of Android OS\label{fig:Android_OS_Structure}}
\end{figure}

\section{Application Development Tools}

Applications for Android are usually written in Java and are run on the 
custom Dalvik VM. Embedded programming is usually difficult because of 
limited visibility of the way the code runs on the target device (a smartphone).
To make development of apps for Android easier, custom tooling for Android 
has been developed that integrates with the Eclipse IDE toolchain.
The tools help to
interface with a development smartphone running an Android OS. They provide a
direct install-uninstall mechanism for applications under development 
and they also provide a debug bridge - called the ADB through which 
the Application code running on the smartphone may be debugged via debugging
tools on the host computer. A logging mechanism is also provided wherein 
application logs running on the device may be made visible in realtime 
on the host computer through the ADB. These tools go a long way in making 
development easier and help the programmer detect root causes of bugs faster.


\section{The Android Application Lifecycle\label{sec:android_lifecycle}}

Android applications are very different from the normal system executables
that we are used to programming. Executables once launched have complete 
system control during execution. They demand resources and release them at 
will depending on how they have been programmed. They are pre-empted and 
resumed transparently by the Kernel scheduler. However, such a mode of
execution is unsuitable for applications built for the mobile device. 
These applications need to be aware of their internal state at all times.
The user may pre-empt any application at any time and the system may 
suspend or even kill applications without warning to reclaim resources.
Applications are therefore expected to be written to follow an event machine 
lifecycle and are expected to save their state whenever they get pre-empted. 
The lifecycle of a typical Android application is shown in 
Figure \ref{fig:android_lifecycle}.


\begin{figure}
\caption{Android Application Lifecycle (Simplified)\label{fig:android_lifecycle}}
\end{figure}

The application typically starts off the 'Created' state, progresses 
to the 'Resumed' state. It may oscillate between the 'Resumed' and 'Paused' states
several times during the course of the execution lifetime of the application 
and then it finally transitions to the 'Finished' state when it is killed by 
the system either automatically or in response to a user action. All 
processing in the application is done either in response to a User action, 
a state change in the application lifecycle or in response to System 
messages delivered asynchronously to the application via \emph{BroadcastReceivers} 
or \emph{Intents}. (\emph{BroadcastReceiver} and \emph{Intent} are important
classes in the Android framework).

\section{System Architecture}

As is clear from the previous section, the Android OS expects applications to 
be event-driven. In our case, events are being generated by the user 
not through direct interaction with the application via the UI but through 
indirect interaction via the sensors onboard the device. This naturally 
leads to a bottom-up design of the system on the lines similar to protocol
stacks seen commonly in the case of Computer Networks. The analogy
being drawn here is that a packet receive event in the case of a 
protocol stack is similar to a sensor event generated for our system. 

The complete layered structure of the application is shown in Figure 
\ref{fig:system_architecture}. 

\begin{figure}
    \centering
    \includegraphics{figures/system_architecture}
    \caption{System Architecture\label{fig:system_architecture}}
\end{figure}

At the lowest layer, we have the \textbf{Sensor Unification Layer}. This layer is 
important as the Android API separates the event delivery mechanism 
for a Wifi SCAN event and the event delivery mechanism for a sensor 
sample event. The rationale behind this being that sensors are passive 
environment samplers while the Wifi NIC is an active communication 
device and is not typically intended to be used as a sensor. The \textbf{Sensor 
Unification Layer} works very hard to unify Wifi SCAN event results and 
sensor sample results into a single uniform events system to which 
a higher layer can subscribe by registering a callback object. Whenever 
a sensor event takes place for which higher layers have requested notification,
all registered callbacks for that event are executed by this layer. Thus,
higher layers can request access to sensor events by just registering an 
appropriate callback with this layer. The unification layer takes care of 
interfacing with the Android SensorManager API and the Android WifiManager API
and exposes lifecycle methods - \tt{pause} and \tt{resume} which free up 
higher layers from performing appropriate registrations and de-registrations
of sensor event handlers when they intend to go to sleep. The class that 
provides the API for the higher layers is the \emph{SensorLifecycleManager} class
and the critical class for implementation of this layer is the 
\emph{HWSensorEventListener} and \emph{WifiScanEventListener} classes. 






The problem being implemented has a natural event-driven layered structure. 
We are taking
low level sensor events being generated at a fast pace and converting 
them to "step" events that take place much more rarely. These step events 
are then processed 

\section{System Implementation of the Lifecycle}

The Android Application Lifecycle referred in Section \ref{sec:android_lifecycle}
primarily deals with high level user actions such as going idle, switching 
off the screen, exiting the application etc. 

\missingfigure{Architecture of system}

\missingfigure{List of major classes}

\missingfigure{Their interactions}
